# 발표 대본 (시스템 개요 및 아키텍처)

## [Slide: System Architecture Overview]

**[인트로]**
네, 다음으로 우리 시스템이 어떻게 구성되어 있는지, **시스템 아키텍처(System Architecture)**에 대해 말씀드리겠습니다.
저희는 사용자의 요청을 처리하는 **Web Server**와, AI가 생각하고 답변을 만드는 **AI Engine**을 효율적으로 결합하기 위해 **하이브리드 아키텍처(Hybrid Architecture)**를 채택했습니다.

**[핵심 구조 설명]**
화면의 다이어그램을 봐주시기 바랍니다. 전체 흐름은 크게 세 단계로 나뉩니다.

1.  **Frontend & Proxy (진입점)**
    - 먼저 사용자가 웹이나 모바일로 접속하면, 가장 앞단에서 **Nginx**가 요청을 받습니다.
    - Nginx는 이미지나 CSS 같은 **정적 파일(Static Files)**은 직접 빠르게 처리하고, 복잡한 로직이 필요한 요청만 뒤쪽의 애플리케이션 서버로 넘겨주는 **문지기(Reverse Proxy)** 역할을 합니다.

2.  **Django Web Application (중추 신경)**
    - 그 뒤에는 **Django**가 기다리고 있습니다. Django는 시스템의 **중추 신경계**와 같습니다.
    - 회원가입, 로그인 같은 **사용자 관리**부터, 채팅 메시지를 DB에 저장하고 불러오는 **데이터 관리**까지 웹 서비스의 전반적인 기능을 담당합니다.
    - 저희는 빠른 개발과 안정성을 위해 Python 기반의 가장 강력한 프레임워크인 Django를 메인으로 선택했습니다.

3.  **AI & Data Layer (두뇌)**
    - 마지막으로, 사용자가 "내 성적에 맞는 학과 추천해줘" 같은 질문을 하면, Django는 **LangGraph** 기반의 AI 엔진을 호출합니다.
    - 이때 AI는 정확한 답변을 위해 두 가지 저장소를 동시에 활용합니다.
        - **MySQL**: 학과별 취업률, 연봉 같은 **정형 데이터**를 조회하고,
        - **Pinecone**: "컴퓨터 다루는 과" 같은 추상적인 질문을 이해하기 위해 **벡터 검색**을 수행합니다.
    - 이 두 데이터를 합쳐서 **OpenAI(GPT)**가 최종 답변을 생성하게 됩니다.

**[상세 특징: Hybrid Approach]**
여기서 특히 강조하고 싶은 점은 **'왜 Django와 SQLAlchemy를 같이 썼는가?'** 입니다.
- 보통 Django는 자체 ORM을 쓰지만, 저희는 **AI 데이터 처리의 유연성**을 위해 **SQLAlchemy**를 추가로 도입했습니다.
- 웹 서비스 로직은 Django로 빠르게 개발하고, AI가 데이터를 조회하고 분석하는 복잡한 쿼리는 SQLAlchemy로 정밀하게 제어함으로써 **개발 생산성**과 **성능**이라는 두 마리 토끼를 잡았습니다.

**[배포 환경 (Deployment)]**
이 모든 시스템은 **Docker** 컨테이너로 패키징되어 있습니다.
- "내 컴퓨터에선 되는데 서버에선 안 되네?" 같은 문제를 원천 차단했습니다.
- 또한 **AWS EC2** 같은 클라우드 환경 어디에나 즉시 배포할 수 있도록 **Stateless**하게 설계되어 있어, 향후 사용자가 늘어나도 유연하게 확장(Scale-out)이 가능합니다.

이상으로 시스템 아키텍처 설명을 마치겠습니다.
